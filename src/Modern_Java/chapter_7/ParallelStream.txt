
Если сомневаетесь — измеряйте. Превратить последовательный поток данных в параллельный
очень просто, но далеко не всегда имеет смысл это делать. Как мы уже продемонстрировали
в этом разделе, параллельный поток данных не всегда работает быстрее своего последовательного
аналога. Более того, параллельные потоки данных иногда работают неожиданным образом, так что
важнейшая рекомендация при выборе между последовательным и параллельным потоками данных — всегда
 проверять их быстродействие с помощью соответствующего теста производительности.

Остерегайтесь упаковки. Автоматические операции упаковки и распаковки могут значительно
снизить производительность. Чтобы можно было избежать подобных операций, в Java 8 предусмотрены
 версии потоков для простых типов данных (IntStream, LongStream и DoubleStream), которые следует
 использовать везде, где только возможно.

Некоторые операции по своей природе работают на параллельных потоках данных хуже,
чем на последовательных. В частности, значительных ресурсов требует выполнение для
параллельных потоков данных таких операций, как limit и findFirst, зависящих от порядка
элементов. Например, операция findAny будет работать быстрее, чем findFirst, поскольку
не обязана анализировать элементы в порядке обнаружения. Упорядоченный поток данных всегда
можно преобразовать в неупорядоченный, вызвав для него метод unordered. Например, с целью
получения N элементов потока, причем не обязательно первых N элементов, эффективнее будет
вызвать метод limit для неупорядоченного параллельного потока, а не потока с заданным порядком
 обнаружения (такого как, например, в случае, когда источник представляет собой список).
 
 Оцените общие вычислительные затраты конвейера операций над потоком. Если обозначить
 N число обрабатываемых элементов, а Q — приблизительные затраты на обработку одного
 элемента в рамках конвейера потока, то суммарные затраты можно приближенно оценить
 как произведение N ∙ Q. Чем выше значение Q, тем больше шансов на хорошую
 производительность при использовании параллельного потока данных.

 
 При небольших объемах данных выбирать параллельный поток данных почти никогда не имеет смысла.
 Преимущества параллельной обработки недостаточны, чтобы перевесить дополнительные затраты
 на процесс распараллеливания.
 
 Необходимо учитывать, насколько хорошо допускает разбиение на порции структура данных,
 лежащая в основе потока. Например, список ArrayList разбивается намного эффективнее,
  чем LinkedList, поскольку первый можно разбить на равные порции без его обхода,
   в отличие от второго. Кроме того, легко разбиваются на порции специализированные
   версии потоков для простых типов данных, созданные с помощью фабричного метода range.
    Наконец, как вы узнаете из раздела 7.3, управлять всеми нюансами этого процесса
    разбиения можно с помощью создания своего собственного сплитератора.

 
 Характеристики потока данных, а также модификация этих характеристик промежуточными
 операциями на протяжении конвейера могут менять производительность процесса разбиения.
  Например, поток с характеристикой SIZED можно разбить на две равные части, которые более
   эффективно — обработать параллельно, но при фильтрации может оказаться отброшено непредсказуемое
   число элементов, вследствие чего размер потока окажется неизвестным
   
   Следует учесть, насколько велики затраты на шаг объединения в завершающей операции
   (например, метод combiner коллектора). Если этот шаг дорогостоящий, то затраты на
    объединение промежуточных результатов отдельных потоков могут перевесить выгоды
    параллельного потока данных в смысле производительности